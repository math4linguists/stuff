Привет! Ещё одна домашка. Она из трёх частей, вторая часть нужна для разогрева 
и если вам скучно делать часть два, пропускайте её: 
особенно важны первая задача и вторая часть третьей задачи.

Домашние задания в курсе не оцениваются и нужны для того, чтобы помогать усвоить пройденные темы.

### часть 1: 
если вы не делали первую домашку, то возьмите её код у кого-то, кто её сделал, и доделывайте его:

* настройте генератор тестовых списков так, что бы он генерировал более-менее длинные списки: длиной от сотни до десяти тысяч
* сделайте десять тысяч экспериментальных запусков, про каждый из которых нужно печатать (один запуск - одна строка tsv-таблицы): 
  * время запуска экспериментального запуска, 
  * время окончания экспериментального запуска, 
  * время работы запуска (как разница времени конца и начала)
  * количество элементов, суммарно входящих в список, на котором происходил запуск.

* загрузите tsv в гуглтаблицы и постройте скеттерплот: ось икс — количество элементов в списке, на котором работала программа, ось игрек —  время работы программы. 

### часть 2:
Бинарное дерево можно хранить в словаре: `{"value": value, "left": left_node, "right": right_node}`.   
`value` -- значение, лежащее в корне дерева,  
`left_node` и `right_node` -- правое и левое поддеревья корня, хранимое в такой же структуре. 

Если поддерева нет, то соответствующее значение `X_node` равно `None`.

**Задача:** напишите функцию, которая будет проверять, есть ли введённое число в хранимом так дереве. Аргументы функции: число для поиска и дерево, в котором искать.

### часть 3:

Префиксное дерево можно хранить в структуре вида `{"prefix1": subtree1, "prefix2": subtree2}`. 
Например, для словаря `кот, компот, кит` дерево выглядит так: 
<div align="center"><img src="https://github.com/math4linguists/stuff/blob/master/img/%D0%A4%D0%B8%D0%B3%D1%83%D1%80%D0%B0%2019.png" alt="trie" width="200"/></div>

```python
{
  "^к": {
    "ит": {},
    "o": {"д": {}, "т": {}}
  }
}
```

**Задача 1:** напишите функцию, которая бы проверяла, есть ли какое-то слово в таком префиксном дереве. Аргументы функции: искомое слово, хранимое вышеописанным образом дерево.
**Задача 2:** напишите функцию, которая бы добавляла в хранимое вышеописанным образом дерево новое слово. Аргументы функции: добавляемое слово, хранимое вышеописанным образом дерево.
